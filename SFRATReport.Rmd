---
title: 'Software Failure and Reliability Assessment Tool: Report'
author: "xxx"
date: '`r format(Sys.time(), "%Y-%m-%d_%H:%M")`'
output:
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
#Libraries Needed to genereate report
library(shiny)
library(DT)
library(gdata)
library(ggplot2)
library(rootSolve)
library(readxl)
library(knitr)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE)
```

```{r, include=FALSE}
##Report Specications file
#Contains arguments to key variables that effect the way the report is generated
source('report-specifications.R')
```

```{r, echo=FALSE}
##DATA PREPROCESSING
source('./SFRAT/utility/data/Data_Tools.R')

#Input excel file with a single sheet for now
d <- dataset
cnames <- colnames(d) # Read column names in the input excel file

#Data conversion depending on the type of the input data
tryCatch({
if("FN" %in% cnames && "IF" %in% cnames && "FT" %in% cnames) {
  	FT <- d$FT
  	IF <- d$IF
  	FN <- d$FN
} else if("FN" %in% cnames && "IF" %in% cnames) {
  	FT <- IF_to_FT(d$IF)
  	IF <- d$IF
  	FN <- d$FN
} else if("FN" %in% cnames && "FT" %in% cnames) {
  	IF <- FT_to_IF(d$FT)
  	FT <- d$FT
  	FN <- d$FN
} else if("T" %in% cnames && "FC" %in% cnames && "CFC" %in% cnames) {
  FC <- d$FC
  CFC <- d$CFC
  FT <- FC_to_FT(d$T,d$FC)
  IF <- FT_to_IF(FT)
  FN <- 1:length(FT)
} else if("T" %in% cnames && "FC" %in% cnames) {
  CFC <- FC_to_CFC(d$FC)
  FT <- FC_to_FT(d$T,d$FC)
  IF <- FT_to_IF(FT)
  FN <- 1:length(FT)
} else if("T" %in% cnames && "CFC" %in% cnames) {
  FC <- CFC_to_FC(d$CFC)
  FT <- FC_to_FT(d$T,d$FC)
  IF <- FT_to_IF(FT)
  FN <- 1:length(FT)
} else{
  print("Upload your input data/file formatted according to the SFRAT guidelines")
}
}, error = function(error_condition){
  print("Unable to load in data.")
})
d <- data.frame("FN"=FN,"IF"=IF,"FT"=FT)
```

#Tab 1: Select, Apply, and Analyze Data

##Sample of the updated data ('`r SheetName`') in different formats:
The table below shows the first ten points of the input data '`r SheetName`'. `FC', `CFC', `FT', `IF', and `FN' indicates failure counts, cumulative failure counts, failure times, interfailure times, and number of failures respectively. 


```{r, echo=FALSE}
if("T" %in% cnames && "FC" %in% cnames && "CFC" %in% cnames) {
list(data.frame("FT"=head(FT),"IF"=head(IF),"FN"=head(FN)),data.frame("FC"=head(FC), "CFC"=head(CFC)))
}else{
  kable(d[1:10,], caption="First ten points of the input data")
}
```

\newpage
##Cumulative failures
Figure below shows the cumulative number of failures as a function a cumulative test time for '`r SheetName`'. Increasing trend indicates detection of more failures. Ideally, the cumulative failure should converge to a constant value as testing progresses indicating zero number of failures in the software.

```{r, echo=FALSE}
plot(
  FT, FN, type="s",
  xlab="Cumulative test time", ylab="Cumulative number of failures",
  main =  bquote("Cumuative Failures vs. cumulative test time:" ~.(SheetName))
)
```

\newpage
##Times between failures/Interfailure times
Ideally, times between failures should increase over time.

```{r, echo=FALSE}
plot(
  FT, IF, type="s",
  xlab="Cumulative test time", ylab="Times between successive failures",
  main = bquote("Interfailure times vs. cumulative test time:" ~.(SheetName))
)
```

\newpage
##Failure intensity
Decrease in failure intensity indicates increase in reliability of the software subjected to testing. Ideally, failure intensity should go to zero.

```{r, echo=FALSE}
plot(
  FT, 1/IF, type="s",
  xlab="Cumulative test time",ylab="Number of failures per unit time",
  main = bquote("Empirical failure intensity vs. cumulative test time:" ~.(SheetName))
)
```

\newpage
##Laplace Trend Test
The red horizontal line in the figure indicates the specified confidence level of `r percent_data_for_PSSE*100`%. Additional default levels in black include 90, 95, 99, 99.9, 99.9999, and 99.999999. Values below these lines indicates that the data exhibits reliability growth with the specified level of statistical significance and it is therefore suitable to apply software reliabity models. 

If the Laplace test statistic increases above the horizontal red line, this indicates that the data does not exhibit reliability growth. Thus, it is unlikely that a model can be applied successfully because the results may be inaccurate.

```{r, echo=FALSE}
laplace_trend_test <- function(inter_failure) {
  n <- length(inter_failure)
  failure_time <- IF_to_FT(inter_failure)   
  laplace_trend <- c()
  laplace_trend[1] <- 0
  for(i in 2:n) {
    sumint <- 0
    for(j in 1:(i-1)) {
      sumint <- sumint + failure_time[j]  
    }
    laplace_trend[i] <-(((1/(i-1))*sumint) -(failure_time[i]/2))/(failure_time[i]*(1/(12*(i-1))^(0.5)))
  }
  trend_data <- data.frame(c(1:length(laplace_trend)),laplace_trend)
  names(trend_data) <- c("Index","Laplace_factor")
  return(trend_data)
}

LTT <- laplace_trend_test(IF)

# Two Tailed test
Confidence.lvl <- confidence_lvl # <-- comes from report-specifications.R
Significance <- qnorm(1 - Confidence.lvl)
Z.value.1 <- qnorm(0.1)
Z.value.2 <- qnorm(0.05)
Z.value.3 <- qnorm(0.01)
Z.value.4 <- qnorm(0.001)
Z.value.5 <- qnorm(0.0000001)
Z.value.6 <- qnorm(0.000000001)

#Display significance lines
localTrendPlot <- 
  ggplot(data = LTT, aes(Index, Laplace_factor)) + 
  geom_step() +
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5)) +
  xlab("Failure Number") +
  scale_x_continuous(breaks = round(seq(0 , max(LTT$Index), by = 20), 1)) +
  ylab("Laplace Test Statistic") +
  ggtitle(bquote("Laplace Trend Test" ~.(SheetName))) + 
  labs(subtitle = bquote("Confidence =" ~.(Confidence.lvl))) +
  geom_hline(yintercept = Significance, color="Red") +
  geom_hline(yintercept = Z.value.1, color="black", linetype = "dotdash", alpha=0.8) +
  geom_hline(yintercept = Z.value.2, color="black", linetype = "dotdash", alpha=0.8) +
  geom_hline(yintercept = Z.value.3, color="black", linetype = "dotdash", alpha=0.8) +
  geom_hline(yintercept = Z.value.4, color="black", linetype = "dotdash", alpha=0.8) +
  geom_hline(yintercept = Z.value.5, color="black", linetype = "dotdash", alpha=0.8) +
  geom_hline(yintercept = Z.value.6, color="black", linetype = "dotdash", alpha=0.8)

localTrendPlot
```

\newpage
##Running arithmetic average
The running arithmetic average, computes and plots a running average of the times between failures. Intuitively, if the time between failures increases then the running arithmetic average increases, indicating system reliability is improving. A decreasing running arithmetic average indicates reliability deterioration.


```{r,echo=FALSE}
running_average_test <- function(inter_failure) {
  n <- length(inter_failure)
  runningAverage <- c()
  for(i in 1:n) {
    sum1 <-0
    for(j in 1:i) {
      sum1 <- sum1 + inter_failure[j]
    }
    runningAverage[i] <- (1/i)*sum1;
  }
  runningAverage <- data.frame(c(1:length(runningAverage)),runningAverage)
  names(runningAverage) <- c("Index","Running_Average")
  return(runningAverage)
}

plot(
  running_average_test(IF), type="s",
  xlab="Failure number", ylab="Running average of interfailure times",
  main=bquote("Running arithmetic average test:"~.(SheetName))
)
```

\newpage
#Tab2: Set Up and Apply Models

```{r, echo=FALSE}
#Add in models to be used
source('./SFRAT/models/DSS/DSS_BM_FT.R')
source('./SFRAT/models/DSS/Model_specifications.R')
source('./SFRAT/models/GO/GO_BM_FT.R')
source('./SFRAT/models/GO/Model_specifications.R')
source('./SFRAT/models/JM/JM_BM.R')
source('./SFRAT/models/JM/Model_specifications.R')
source('./SFRAT/models/GM/GM_BM.R')
source('./SFRAT/models/GM/Model_specifications.R')
source('./SFRAT/models/Wei/Wei_NM_FT.R')
source('./SFRAT/models/Wei/Model_specifications.R')
```

##Cumulative failures
The figure show model result plots for the input data '`r SheetName`'. Models `r models_to_apply` are applied. 

```{r, echo=FALSE}
models <- c() #used for legend
modelList <- list() #passed to plot
modelIterator <- 1;
#colors <- c("navy","red","green","firebrick4","magenta") #for plot line colors
#TODO Fix title

#Apply appropriate models comes from report-specifications.R
  DSS = c()
  if('DSS' %in% models_to_apply && DSS_BM_MLE(FT)!="nonconvergence") { 
    DSS <-  DSS_MVF(DSS_BM_MLE(FT),d)[,2]
    modelList[[modelIterator]] = DSS
    models <- append(models, "DSS")
    #colors <- append(colors, DSS_plotcolor)
    modelIterator <- modelIterator + 1
  }

  GO = c()
  if('GO' %in% models_to_apply && GO_BM_MLE(FT)!="nonconvergence") {
    GO <- GO_MVF(GO_BM_MLE(FT),d)[,1]
    modelList[[modelIterator]] = GO
    models <- append(models, "GO")
   # colors <- append(colors, GO_plotcolor)
    modelIterator <- modelIterator + 1
  }

  JM = c()
  if('JM' %in% models_to_apply && JM_BM_MLE(IF)!="nonconvergence") { 
    JM <- JM_MVF(JM_BM_MLE(IF),d)[,1]
    modelList[[modelIterator]] = JM
    models <- append(models, "JM")
    #colors <- append(colors, JM_plotcolor)
    modelIterator <- modelIterator + 1
  }

  GM = c()
  if('GM' %in% models_to_apply && GM_BM_MLE(IF)!="nonconvergence") { 
    GM <- GM_MVF(GM_BM_MLE(IF),d)[,2]
    modelList[[modelIterator]] = GM
    models <- append(models, "GM")
   # colors <- append(colors, GM_plotcolor)
    modelIterator <- modelIterator + 1
  }

  Wei = c()
  if('Wei' %in% models_to_apply && Wei_NM_MLE(FT)!="nonconvergence") { 
    Wei <- Wei_MVF(Wei_NM_MLE(FT),d)[,2]
    modelList[[modelIterator]] = Wei
    models <- append(models, "Wei") 
    #colors <- append(colors, Wei_plotcolor)
    modelIterator <- modelIterator + 1
  }

hxy <- data.frame(modelList)
ntrees <- length(models)

plot(FT,FN, type="n",xlab="Cumulative test time", ylab="Cumulative failures")
linetype <- c("p","l","o","b","c","s","S","h")  
lines(FT, FN, type="s")

for (i in 1:ntrees) {
  lines(FT, hxy[,i], type="l", col=colors[i])
}

title(bquote("Cumualtive failures vs. cumualtive test time:" ~.(SheetName)))
legend("bottomright", legend=models, lty=c(1,1), cex=0.8, col=colors)
```

\newpage
##Times between failures

```{r,echo=FALSE}
modelList <- list() #passed to plot
modelIterator <- 1; #used for creating a list
#colors <- c("navy","red","green","firebrick4","magenta")

#Apply appropriate models comes from report-specifications.R
DSS = c()
if('DSS' %in% models) { 
  DSS <- DSS_MTTF(DSS_BM_MLE(FT),d)[,2]
  modelList[[modelIterator]] = DSS
  modelIterator <- modelIterator + 1
}

GO = c()
if('GO' %in% models) {
  GO <- GO_MTTF(GO_BM_MLE(FT),d)[,2]
  modelList[[modelIterator]] = GO
  modelIterator <- modelIterator + 1
}

JM = c()
if('JM' %in% models) { 
  JM <- JM_MTTF(JM_BM_MLE(IF),d)[,2]
  modelList[[modelIterator]] = JM
  modelIterator <- modelIterator + 1
}

GM = c()
if('GM' %in% models) { 
  GM <- GM_MTTF(GM_BM_MLE(IF),d)[,2]
  modelList[[modelIterator]] = GM
  modelIterator <- modelIterator + 1
}

Wei = c()
if('Wei' %in% models) { 
  Wei <- Wei_MTTF(Wei_NM_MLE(FT),d)[,2]
  modelList[[modelIterator]] = Wei
  modelIterator <- modelIterator + 1
}

hxy <- data.frame(modelList)
ntrees <- length(models)

plot(
  FT, IF, type="n",
  xlab="Cumulative test time", ylab="Times between failures"
)
linetype <- c("p","l","o","b","c","s","S","h")  
lines(FT, IF, type="s")

for (i in 1:ntrees) {
  lines(FT, hxy[,i], type="l", col=colors[i])
}

title(bquote("Times between failures vs. cumualtive test time" ~.(SheetName)))
legend("topleft", legend=models, lty=c(1,1), cex=0.8, col=colors)
```

\newpage
##Failure intensity

```{r, echo=FALSE}
modelList <- list() #passed to plot
modelIterator <- 1;


#Apply appropriate models comes from report-specifications.R
DSS = c()
if('DSS' %in% models) { 
  DSS <- DSS_FI(DSS_BM_MLE(FT),d)[,2];
  modelList[[modelIterator]] = DSS
  modelIterator <- modelIterator + 1
}

GO = c()
if('GO' %in% models) {
  GO <- GO_FI(GO_BM_MLE(FT),d)[,2];
  modelList[[modelIterator]] = GO
  modelIterator <- modelIterator + 1
}

JM = c()
if('JM' %in% models) { 
  JM <- JM_FI(JM_BM_MLE(IF),d)[,2]; 
  modelList[[modelIterator]] = JM
  modelIterator <- modelIterator + 1
}

GM = c()
if('GM' %in% models) { 
  GM <- GM_FI(GM_BM_MLE(IF),d)[,2]; 
  modelList[[modelIterator]] = GM
  modelIterator <- modelIterator + 1
}

Wei = c()
if('Wei' %in% models) { 
  Wei <- Wei_FI(Wei_NM_MLE(FT),d)[,2]; 
  modelList[[modelIterator]] = Wei
  modelIterator <- modelIterator + 1
}

hxy <- data.frame(modelList)
ntrees <- length(models)

tempFI <- 1/IF
tempFI[is.infinite(tempFI)] <- 0
upLim <- max(max(Wei),max(GO),max(DSS),max(JM),max(GM))

plot(
  FT, tempFI, type="n",ylim=c(min(tempFI),min(upLim,max(tempFI))),
  xlab="Cumulative test time", ylab="Failure intensity"
)
linetype <- c("p","l","o","b","c","s","S","h")  
lines(FT, tempFI, type="s")

for (i in 1:ntrees) {
  lines(FT, hxy[,i], type="l", col=colors[i])
}

title(bquote("Failure intensity vs. Cumualtive test time" ~.(SheetName)))
legend("topright", legend=models, lty=c(1,1), cex=0.8, col=colors)
```

\newpage
##Reliability growth

```{r,echo=FALSE}
#Mission time delta value; comes from report-specifications.R
modelList <- list() #passed to plot
modelIterator <- 1;

#Apply appropriate models comes from report-specifications.R
DSS = c()
if('DSS' %in% models) { 
  DSS <- DSS_R_growth(DSS_BM_MLE(FT),d, mission_time)[,2]
  modelList[[modelIterator]] = DSS
  modelIterator <- modelIterator + 1
}

GO = c()
if('GO' %in% models) {
  GO <- GO_R_growth(GO_BM_MLE(FT),d,mission_time)[,2]
  modelList[[modelIterator]] = GO
  modelIterator <- modelIterator + 1
}

JM = c()
if('JM' %in% models) { 
  JM <- JM_R_growth(JM_BM_MLE(FT),d,mission_time)[,2]
  modelList[[modelIterator]] = JM
  modelIterator <- modelIterator + 1
}

GM = c()
if('GM' %in% models) {
  GM <- GM_R_growth(GM_BM_MLE(FT),d,mission_time)[,2]
  modelList[[modelIterator]] = GM
  modelIterator <- modelIterator + 1
}

Wei = c()
if('Wei' %in% models) { 
  Wei <- Wei_R_growth(Wei_NM_MLE(FT),d,mission_time)[,2]
  modelList[[modelIterator]] = Wei
  modelIterator <- modelIterator + 1
}

hxy <- data.frame(modelList)
ntrees <- length(hxy)

plot(
  FT, 
  seq(from=0, to=max(hxy), by=max(hxy)/(length(FT)-1)),
  type="n",
  xlab="Cumulative test time", ylab="Reliability growth"
)

linetype <- c("p","l","o","b","c","s","S","h")  

for (i in 1:ntrees) { 
  lines(FT, hxy[,i], type="l", col=colors[i]) ##Limit the upperbound to maximum value
} 

title(bquote("Reliability growth vs. cumualtive test time" ~.(SheetName)))
legend("topleft", legend=models, lty=c(1,1), cex=0.8, col=colors)
```

\newpage
#Tab3: Query Model Results
The plots and tabular displays of model results can provide a good overview of what the different models predict for the future failure behavior of the system being analyzing. However, there are some details that are difficult to see in the plots and tables, so the SFRAT allows detailed queries of the models to answer the following questions:

How many more failures will be observed in a given amount of time?

How long will it take to observe a given number of failures?

How much more testing time will be needed to obtain a given reliability for a specified operating time? 

```{r,echo=FALSE}
source('./SFRAT/utility/prediction/Detailed_prediction.R')

#Setting Up The Table
predTable <- matrix(NA, nrow = length(models) , ncol = 3)
rownames(predTable) <- models
colnames(predTable) <- c("Time to achieve specified reliability","Expected number of failures","Expected time to N failure")

##Calulating Future Failures
#Time to achieve specified reliability
options(digits=4)
firstCol <- c() #First column of prediction table

if('DSS' %in% models) { 
  firstCol=append(firstCol,get_reliability_t("DSS",DSS_BM_MLE(FT),desired_reliability,reliability_interval_length,last(FT),num_failures_to_predict))
}

if('GO' %in% models) {
  firstCol=append(firstCol,get_reliability_t("GO",GO_BM_MLE(FT),desired_reliability,reliability_interval_length,last(FT),num_failures_to_predict))
}

if('JM' %in% models) { 
  firstCol=append(firstCol,get_reliability_t("JM",JM_BM_MLE(IF),desired_reliability,reliability_interval_length,last(IF),num_failures_to_predict))
}

if('GM' %in% models) {
  firstCol=append(firstCol,get_reliability_t("GM",GM_BM_MLE(IF),desired_reliability,reliability_interval_length,last(FT),num_failures_to_predict))##The right hand side is creating a null model. TODO: Refer back to the original file to solve this precision issue
}

if('Wei' %in% models) { 
  firstCol=append(firstCol,get_reliability_t("Wei",Wei_NM_MLE(FT),desired_reliability,reliability_interval_length,last(FT),num_failures_to_predict))
}

predTable[,1] <- firstCol

#Expected number of failures
secondCol <- c()
if('DSS' %in% models) { 
  secondCol=append(secondCol, get_prediction_k("DSS",DSS_BM_MLE(FT),additional_time_software_will_run,last(FT),length(FT)))
}

if('GO' %in% models) {
  secondCol=append(secondCol,get_prediction_k("GO",GO_BM_MLE(FT),additional_time_software_will_run,last(FT),length(FT)))
}

if('JM' %in% models) { 
  secondCol=append(secondCol,get_prediction_k("JM",JM_BM_MLE(IF),additional_time_software_will_run,last(FT),length(FT)))
}

if('GM' %in% models) {
  secondCol=append(secondCol,get_prediction_k("GM",GM_BM_MLE(IF),additional_time_software_will_run,last(FT),length(FT)))
}

if('Wei' %in% models) { 
  secondCol=append(secondCol, get_prediction_k("Wei",Wei_NM_MLE(FT),additional_time_software_will_run,last(FT),length(FT)))
}

predTable[,2] <- secondCol

#Expected time to N failure
thirdCol <- c()
if('DSS' %in% models) { 
  thirdCol=append(thirdCol,last(get_prediction_t("DSS",DSS_BM_MLE(FT),num_failures_to_predict,last(FT),length(FT))))
}

if('GO' %in% models) {
  thirdCol=append(thirdCol,last(get_prediction_t("GO",GO_BM_MLE(FT),num_failures_to_predict,last(FT),length(FT))))
}

if('JM' %in% models) { 
  thirdCol=append(thirdCol,last(get_prediction_t("JM",JM_BM_MLE(IF),num_failures_to_predict,last(FT),length(FT))))
}

if('GM' %in% models) {
  thirdCol=append(thirdCol,last(get_prediction_t("GM",GM_BM_MLE(IF),num_failures_to_predict,last(FT),length(FT))))
}

if('Wei' %in% models) { 
  thirdCol=append(thirdCol,last(get_prediction_t("Wei",Wei_NM_MLE(FT),num_failures_to_predict,last(FT),length(FT))))
}

predTable[,3] <- thirdCol

#As of now, the table can only hold a single value
#TODO:multiple rows for each falure prediction

kable(predTable,align='r',digits=4)
```

\newpage
# Tab4: Evaluate Models
After applying one or more models to a set of failure data, the user can assess which model or models produce better predictions. This version of the SFRAT includes two methods to evaluate the performance of the models to identify those that will provide better predictions â€“ the Akaike Information Criterion (AIC) and Predictive Sum of Squared Error (PSSE).

```{r,echo=FALSE}

source('./SFRAT/utility/metrics/GOF.R')
#Setup Table
GOFTable <- matrix(NA, nrow = length(models), ncol = 2)
rownames(GOFTable) <- models
colnames(GOFTable) <- c(bquote("Akaike Information Criterion (AIC)"), bquote("Predictive sum of squares error (PSSE)" ~.(percent_data_for_PSSE)))

#Calculate AIC
GOFFirstCol <- c()
if('DSS' %in% models) { 
  GOFFirstCol=append(GOFFirstCol,aic(2, DSS_lnL(FT, DSS_BM_MLE(FT))))
}

if('GO' %in% models) {
  GOFFirstCol=append(GOFFirstCol,aic(2, GO_lnL(FT, GO_BM_MLE(FT))))
}

if('JM' %in% models) { 
  GOFFirstCol=append(GOFFirstCol,aic(2, JM_lnL(IF, JM_BM_MLE(IF))))
}

if('GM' %in% models) {
  GOFFirstCol=append(GOFFirstCol,aic(2, GM_lnL(IF, GM_BM_MLE(IF))))
}

if('Wei' %in% models) { 
  GOFFirstCol=append(GOFFirstCol,aic(3, Wei_lnL(FT, Wei_NM_MLE(FT))))
}


GOFFirstCol <-  round(GOFFirstCol,digits=2)
fircol <- c()
for(i in 1:length(models)){
  if(GOFFirstCol[i]==min(GOFFirstCol)){
    fircol <- append(fircol,paste(c("*",GOFFirstCol[i]),collapse=""))
  }else{
    fircol <- append(fircol,GOFFirstCol[i])
  }
  i=i+1;
}
GOFTable[,1] <- fircol

#Calculate PSSE
GOFSecondCol <- c()
if('DSS' %in% models) { 
  GOFSecondCol=append(GOFSecondCol,psse("DSS", FT, DSS_BM_MLE(FT), percent_data_for_PSSE))
}

if('GO' %in% models) {
  GOFSecondCol=append(GOFSecondCol,psse("GO", FT, GO_BM_MLE(FT), percent_data_for_PSSE))
}

if('JM' %in% models) { 
  GOFSecondCol=append(GOFSecondCol, psse("JM", FT, JM_BM_MLE(IF), percent_data_for_PSSE))
}

if('GM' %in% models) {
  GOFSecondCol=append(GOFSecondCol,psse("GM", FT, GM_BM_MLE(IF), percent_data_for_PSSE))
}

if('Wei' %in% models) { 
  GOFSecondCol=append(GOFSecondCol, psse("Wei", FT, Wei_NM_MLE(FT), percent_data_for_PSSE))
}

GOFSecondCol <-  round(GOFSecondCol,digits=2)
seccol <- c()
for(i in 1:length(models)){
  if(GOFSecondCol[i]==min(GOFSecondCol)){
    seccol <- append(seccol,paste(c("*",GOFSecondCol[i]),collapse=""))
  }else{
    seccol <- append(seccol,GOFSecondCol[i])
  }
  i=i+1;
}

GOFTable[,2] <- seccol

kable(GOFTable,align='r')

```


##Smaller values of AIC and PSSE values are preferred.